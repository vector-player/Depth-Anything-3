#!/usr/bin/env python3
"""
Extract K-matrix (camera intrinsics) from Depth-Anything-3.

This script can extract camera intrinsics (K-matrix) in two ways:
1. Direct image processing: Process images directly using DA3 API (one-command solution)
2. NPZ extraction: Extract from NPZ files generated by DA3 CLI commands

Usage:
    # Method 1: Process image directly (one command)
    python estimate_k_matrix.py --image photo.jpg --output K.txt

    # Method 2: Extract from NPZ file (two-step: da3 CLI + this script)
    python estimate_k_matrix.py --npz ./output/exports/mini_npz/results.npz --output K.txt

    # Process multiple images directly
    python estimate_k_matrix.py --image-dir ./images/ --output-dir ./K_matrices --batch

    # Extract all K-matrices from batch processing NPZ
    python estimate_k_matrix.py --npz ./output/exports/mini_npz/results.npz --output-dir ./K_matrices --batch
"""

import argparse
import sys
from pathlib import Path
import numpy as np
import glob

# Try to import DA3 API for direct image processing
try:
    import torch
    from depth_anything_3.api import DepthAnything3
    DA3_AVAILABLE = True
except ImportError:
    DA3_AVAILABLE = False


def estimate_k_matrix_from_image(
    image_path: Path,
    output_path: Path,
    model_name: str = "depth-anything/DA3-LARGE-1.1",
    device: str = "cuda",
    process_res: int = 504
) -> bool:
    """
    Process image directly using DA3 API and extract K-matrix.
    
    Args:
        image_path: Path to input image file
        output_path: Path to output K-matrix file
        model_name: DA3 model name or HuggingFace path
        device: Device to use ('cuda' or 'cpu')
        process_res: Processing resolution
    
    Returns:
        True if successful, False otherwise
    """
    if not DA3_AVAILABLE:
        print("Error: DA3 API not available. Cannot process images directly.")
        print("Please install Depth-Anything-3 or use --npz mode instead.")
        return False
    
    # Validate input image exists
    if not image_path.exists():
        print(f"Error: Image file not found: {image_path}")
        return False
    
    # Validate output directory exists
    output_dir = output_path.parent
    if not output_dir.exists():
        print(f"Creating output directory: {output_dir}")
        output_dir.mkdir(parents=True, exist_ok=True)
    
    # Load and validate image
    try:
        from PIL import Image
        image = Image.open(str(image_path))
        w, h = image.size
        print(f"Loading image: {image_path}")
        print(f"Image size: {w} x {h} pixels")
    except Exception as e:
        print(f"Error: Failed to load image: {e}")
        print("Please ensure the file is a valid image format (PNG, JPG, etc.)")
        return False
    
    # Initialize DA3 model
    print(f"Initializing DA3 model: {model_name}")
    try:
        model = DepthAnything3.from_pretrained(model_name)
        model_device = torch.device(device)
        model = model.to(model_device)
        print(f"Model loaded successfully on {device}")
    except Exception as e:
        print(f"Error: Failed to initialize DA3 model: {e}")
        print("This may be due to missing model files, GPU issues, or network problems.")
        return False
    
    # Run inference
    print(f"Processing image with DA3...")
    try:
        prediction = model.inference(
            image=[str(image_path)],
            process_res=process_res
        )
    except Exception as e:
        print(f"Error: Failed to process image: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    # Extract K-matrix
    if prediction.intrinsics is None:
        print("Error: Camera intrinsics not found in DA3 output.")
        print("Available attributes:", [attr for attr in dir(prediction) if not attr.startswith('_')])
        return False
    
    intrinsics = prediction.intrinsics
    if len(intrinsics) == 0:
        print("Error: No intrinsics found in prediction.")
        return False
    
    K = intrinsics[0]  # Get first (and only) image's K-matrix
    
    # Validate K-matrix shape
    if K.shape != (3, 3):
        print(f"Error: Invalid K-matrix shape: {K.shape}, expected (3, 3)")
        return False
    
    # Extract parameters
    fx = float(K[0, 0])
    fy = float(K[1, 1])
    cx = float(K[0, 2])
    cy = float(K[1, 2])
    
    print(f"\nK-matrix for image:")
    print(f"  fx (focal length X): {fx:.6f} pixels")
    print(f"  fy (focal length Y): {fy:.6f} pixels")
    print(f"  cx (principal point X): {cx:.6f} pixels")
    print(f"  cy (principal point Y): {cy:.6f} pixels")
    
    # Save K-matrix to file
    print(f"\nSaving K-matrix to: {output_path}")
    np.savetxt(str(output_path), K, fmt='%.6f')
    
    # Verify the saved file
    if output_path.exists():
        print("✓ K-matrix saved successfully!")
        print(f"\nK-matrix (3x3):")
        print(K)
        print(f"\nFile format: Space-separated values, 3 rows x 3 columns")
        return True
    else:
        print(f"Error: Failed to save K-matrix to {output_path}")
        return False


def estimate_k_matrices_from_images(
    image_dir: Path,
    output_dir: Path,
    model_name: str = "depth-anything/DA3-LARGE-1.1",
    device: str = "cuda",
    process_res: int = 504,
    image_extensions: tuple = ('.jpg', '.jpeg', '.png', '.webp', '.bmp')
) -> bool:
    """
    Process multiple images directly and extract K-matrices.
    
    Args:
        image_dir: Directory containing images
        output_dir: Directory to save K-matrix files
        model_name: DA3 model name or HuggingFace path
        device: Device to use ('cuda' or 'cpu')
        process_res: Processing resolution
        image_extensions: Tuple of image file extensions to process
    
    Returns:
        True if successful, False otherwise
    """
    if not DA3_AVAILABLE:
        print("Error: DA3 API not available. Cannot process images directly.")
        print("Please install Depth-Anything-3 or use --npz mode instead.")
        return False
    
    # Validate image directory exists
    if not image_dir.exists():
        print(f"Error: Image directory not found: {image_dir}")
        return False
    
    # Create output directory
    if not output_dir.exists():
        print(f"Creating output directory: {output_dir}")
        output_dir.mkdir(parents=True, exist_ok=True)
    
    # Find all images
    image_files = []
    for ext in image_extensions:
        image_files.extend(glob.glob(str(image_dir / f"*{ext}")))
        image_files.extend(glob.glob(str(image_dir / f"*{ext.upper()}")))
    
    image_files = sorted([Path(f) for f in image_files])
    
    if len(image_files) == 0:
        print(f"Error: No images found in {image_dir}")
        print(f"Supported extensions: {', '.join(image_extensions)}")
        return False
    
    print(f"Found {len(image_files)} images to process")
    
    # Initialize DA3 model (load once, reuse for all images)
    print(f"Initializing DA3 model: {model_name}")
    try:
        model = DepthAnything3.from_pretrained(model_name)
        model_device = torch.device(device)
        model = model.to(model_device)
        print(f"Model loaded successfully on {device}")
    except Exception as e:
        print(f"Error: Failed to initialize DA3 model: {e}")
        return False
    
    # Process each image
    success_count = 0
    for i, image_path in enumerate(image_files):
        print(f"\n[{i+1}/{len(image_files)}] Processing: {image_path.name}")
        
        try:
            # Run inference
            prediction = model.inference(
                image=[str(image_path)],
                process_res=process_res
            )
            
            # Extract K-matrix
            if prediction.intrinsics is None or len(prediction.intrinsics) == 0:
                print(f"  Warning: No intrinsics found, skipping")
                continue
            
            K = prediction.intrinsics[0]
            
            # Validate K-matrix shape
            if K.shape != (3, 3):
                print(f"  Warning: Invalid K-matrix shape: {K.shape}, skipping")
                continue
            
            # Generate output filename
            output_path = output_dir / f"K_{i:04d}.txt"
            
            # Save K-matrix
            np.savetxt(str(output_path), K, fmt='%.6f')
            print(f"  ✓ Saved K-matrix to {output_path}")
            success_count += 1
            
        except Exception as e:
            print(f"  Error processing {image_path.name}: {e}")
            continue
    
    print(f"\n{'='*60}")
    print(f"SUCCESS: Extracted {success_count}/{len(image_files)} K-matrices")
    print(f"Output directory: {output_dir}")
    print(f"{'='*60}")
    
    return success_count > 0


def extract_k_matrix(npz_path: Path, output_path: Path, image_index: int = 0) -> bool:
    """
    Extract K-matrix from NPZ file for a specific image.
    
    Args:
        npz_path: Path to NPZ file containing DA3 results
        output_path: Path to output K-matrix file
        image_index: Index of the image to extract (default: 0 for first image)
    
    Returns:
        True if successful, False otherwise
    """
    # Validate NPZ file exists
    if not npz_path.exists():
        print(f"Error: NPZ file not found: {npz_path}")
        return False
    
    # Validate output directory exists
    output_dir = output_path.parent
    if not output_dir.exists():
        print(f"Creating output directory: {output_dir}")
        output_dir.mkdir(parents=True, exist_ok=True)
    
    # Load NPZ file
    print(f"Loading NPZ file: {npz_path}")
    try:
        data = np.load(str(npz_path))
    except Exception as e:
        print(f"Error: Failed to load NPZ file: {e}")
        return False
    
    # Check if intrinsics exist
    if 'intrinsics' not in data:
        print("Error: 'intrinsics' not found in NPZ file.")
        print(f"Available keys: {list(data.keys())}")
        return False
    
    intrinsics = data['intrinsics']
    print(f"Found intrinsics with shape: {intrinsics.shape}")
    
    # Validate image index
    if image_index >= len(intrinsics):
        print(f"Error: Image index {image_index} out of range (0-{len(intrinsics)-1})")
        return False
    
    # Extract K-matrix for the specified image
    K = intrinsics[image_index]
    
    # Validate K-matrix shape
    if K.shape != (3, 3):
        print(f"Error: Invalid K-matrix shape: {K.shape}, expected (3, 3)")
        return False
    
    # Extract parameters
    fx = float(K[0, 0])
    fy = float(K[1, 1])
    cx = float(K[0, 2])
    cy = float(K[1, 2])
    
    print(f"\nK-matrix for image {image_index}:")
    print(f"  fx (focal length X): {fx:.6f} pixels")
    print(f"  fy (focal length Y): {fy:.6f} pixels")
    print(f"  cx (principal point X): {cx:.6f} pixels")
    print(f"  cy (principal point Y): {cy:.6f} pixels")
    
    # Save K-matrix to file
    print(f"\nSaving K-matrix to: {output_path}")
    np.savetxt(str(output_path), K, fmt='%.6f')
    
    # Verify the saved file
    if output_path.exists():
        print("✓ K-matrix saved successfully!")
        print(f"\nK-matrix (3x3):")
        print(K)
        print(f"\nFile format: Space-separated values, 3 rows x 3 columns")
        return True
    else:
        print(f"Error: Failed to save K-matrix to {output_path}")
        return False


def extract_all_k_matrices(npz_path: Path, output_dir: Path) -> bool:
    """
    Extract all K-matrices from NPZ file and save them individually.
    
    Args:
        npz_path: Path to NPZ file containing DA3 results
        output_dir: Directory to save all K-matrix files
    
    Returns:
        True if successful, False otherwise
    """
    # Validate NPZ file exists
    if not npz_path.exists():
        print(f"Error: NPZ file not found: {npz_path}")
        return False
    
    # Create output directory
    if not output_dir.exists():
        print(f"Creating output directory: {output_dir}")
        output_dir.mkdir(parents=True, exist_ok=True)
    
    # Load NPZ file
    print(f"Loading NPZ file: {npz_path}")
    try:
        data = np.load(str(npz_path))
    except Exception as e:
        print(f"Error: Failed to load NPZ file: {e}")
        return False
    
    # Check if intrinsics exist
    if 'intrinsics' not in data:
        print("Error: 'intrinsics' not found in NPZ file.")
        print(f"Available keys: {list(data.keys())}")
        return False
    
    intrinsics = data['intrinsics']
    num_images = len(intrinsics)
    print(f"Found {num_images} K-matrices in NPZ file")
    
    # Extract and save each K-matrix
    success_count = 0
    for i, K in enumerate(intrinsics):
        # Validate K-matrix shape
        if K.shape != (3, 3):
            print(f"Warning: Invalid K-matrix shape for image {i}: {K.shape}, skipping")
            continue
        
        # Generate output filename
        output_path = output_dir / f"K_{i:04d}.txt"
        
        # Save K-matrix
        try:
            np.savetxt(str(output_path), K, fmt='%.6f')
            print(f"✓ Saved K-matrix {i} to {output_path}")
            success_count += 1
        except Exception as e:
            print(f"Error: Failed to save K-matrix {i}: {e}")
    
    print(f"\n{'='*60}")
    print(f"SUCCESS: Extracted {success_count}/{num_images} K-matrices")
    print(f"Output directory: {output_dir}")
    print(f"{'='*60}")
    
    return success_count > 0


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Extract K-matrix (camera intrinsics) from Depth-Anything-3",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Method 1: Process image directly (one command)
  python estimate_k_matrix.py --image photo.jpg --output K.txt
  
  # Method 2: Extract from NPZ file (two-step: da3 CLI + this script)
  python estimate_k_matrix.py --npz ./output/exports/mini_npz/results.npz --output K.txt
  
  # Process multiple images directly
  python estimate_k_matrix.py --image-dir ./images/ --output-dir ./K_matrices --batch
  
  # Extract all K-matrices from batch processing NPZ
  python estimate_k_matrix.py --npz ./output/exports/mini_npz/results.npz --output-dir ./K_matrices --batch
  
  # With custom model and device
  python estimate_k_matrix.py --image photo.jpg --output K.txt --model depth-anything/DA3-BASE --device cpu
        """
    )
    
    # Input source arguments (mutually exclusive)
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument(
        '--image',
        type=str,
        help='Path to input image file (for direct processing)'
    )
    input_group.add_argument(
        '--image-dir',
        type=str,
        help='Directory containing images to process (requires --batch)'
    )
    input_group.add_argument(
        '--npz',
        type=str,
        help='Path to NPZ file containing DA3 results (e.g., ./output/exports/mini_npz/results.npz)'
    )
    
    parser.add_argument(
        '--output',
        type=str,
        default=None,
        help='Path to output K-matrix file (for single extraction, e.g., K.txt)'
    )
    
    parser.add_argument(
        '--output-dir',
        type=str,
        default=None,
        help='Directory to save K-matrices (for batch extraction, e.g., ./K_matrices)'
    )
    
    parser.add_argument(
        '--image-index',
        type=int,
        default=0,
        help='Index of the image to extract from NPZ (default: 0 for first image)'
    )
    
    parser.add_argument(
        '--batch',
        action='store_true',
        help='Extract all K-matrices (requires --output-dir)'
    )
    
    # Model and processing options (for direct image processing)
    parser.add_argument(
        '--model',
        type=str,
        default='depth-anything/DA3-LARGE-1.1',
        help='DA3 model name or HuggingFace path (default: depth-anything/DA3-LARGE-1.1)'
    )
    
    parser.add_argument(
        '--device',
        type=str,
        default='cuda',
        choices=['cuda', 'cpu'],
        help='Device to use for processing (default: cuda)'
    )
    
    parser.add_argument(
        '--process-res',
        type=int,
        default=504,
        help='Processing resolution (default: 504)'
    )
    
    args = parser.parse_args()
    
    # Route to appropriate function based on input type
    if args.image:
        # Direct image processing mode
        if args.output is None:
            print("Error: --output is required when using --image")
            return 1
        image_path = Path(args.image).resolve()
        output_path = Path(args.output).resolve()
        success = estimate_k_matrix_from_image(
            image_path,
            output_path,
            model_name=args.model,
            device=args.device,
            process_res=args.process_res
        )
    elif args.image_dir:
        # Batch image processing mode
        if args.output_dir is None:
            print("Error: --output-dir is required when using --image-dir")
            return 1
        image_dir = Path(args.image_dir).resolve()
        output_dir = Path(args.output_dir).resolve()
        success = estimate_k_matrices_from_images(
            image_dir,
            output_dir,
            model_name=args.model,
            device=args.device,
            process_res=args.process_res
        )
    elif args.npz:
        # NPZ extraction mode (existing functionality)
        npz_path = Path(args.npz).resolve()
        if args.batch:
            if args.output_dir is None:
                print("Error: --output-dir is required when using --batch")
                return 1
            output_dir = Path(args.output_dir).resolve()
            success = extract_all_k_matrices(npz_path, output_dir)
        else:
            if args.output is None:
                print("Error: --output is required when not using --batch")
                return 1
            output_path = Path(args.output).resolve()
            success = extract_k_matrix(npz_path, output_path, args.image_index)
    
    if success:
        return 0
    else:
        return 1


if __name__ == '__main__':
    sys.exit(main())
